// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0



syntax = "proto3";

package com.daml.ledger.api.v2;

import "com/daml/ledger/api/v2/event.proto";
// TODO: build a unified filter proto
import "com/daml/ledger/api/v2/contract_state/filter.proto";
import "google/protobuf/wrappers.proto";



option java_outer_classname = "EventsServiceServiceOuterClass";
option java_package = "com.daml.ledger.api.v2";
option csharp_namespace = "Com.Daml.Ledger.Api.V2";


service EventsService {
  // Get the address of a recent transaction as of which an event source can be provided.
  rpc GetRecentSnapshotOffset(GetRecentSnapshotOffsetRequest) returns (GetRecentSnapshotOffsetResponse);

  // Stream events while first serving all events required to reconstruct a state snapshot as
  // of a given transaction, and afterwards streaming changes to that state.
  rpc StreamEvents (StreamEventsRequest) returns (stream StreamEventsResponse);
}


// Transaction and event addresses
//////////////////////////////////

// A participant-wide address of a transaction and the state it may depend on.
message TransactionAddress {
  // The same absolute offset as in the v1 Ledger API.
  string offset = 1; 
}

// A ledger-wide address of an event and the state it may depend on.
// Comparisons are done in lexicographic order of the fields.
message EventAddress {
  TransactionAddress transaction_address = 1;
  
  // An index of the event within the transaction which is stable across participant nodes.
  //
  // Note: ledgers can decide to hide the node counts by assigning these indices using a
  // "monotone minimal perfect hash function", cf. https://www.cc.gatech.edu/~aboldyre/papers/operev.pdf
  int32 transaction_event_index = 2;
}


// Snapshots
////////////

message GetRecentSnapshotOffsetRequest {}

message GetRecentSnapshotOffsetResponse {
  // The address of the last transaction included in the snapshot.
  TransactionAddress snapshot_transaction_offset = 1;
}


// Event Streaming
//////////////////

message StreamEventsRequest {
  // The address of the last transaction included in the snapshot.
  // Retrieved from `GetRecentSnapshotOffset` or from client-side
  // storage in case of resuming a stream.
  //
  // Required.
  TransactionAddress snapshot_event_offset = 1;

  // Optional offset after which to serve the first event, which can
  // be set to resume streaming events.
  EventAddress after_event_offset = 2;

  // Projection determining what kind of events to serve with what data.
  TransactionProjection projection = 3; 

  // Filter determining which of the projected events to serve.
  // Required
  // 
  // TODO: expand filter or projection to select domains to consider.
  TransactionFilter filter = 4;

}

// The server guarantees to provide at least one `StreamEventsResponse` 
// every 100ms after ingesting new events from the subscribed domains.
message StreamEventsResponse {
  // The offset of this event, which is strictly monotonically increasing
  // for consecutive events wrt the order on `EventAddress`s.
  //
  // Thus all events from the same transaction will be served consecutively
  // and be assigned the same `TransactionAddress`.
  EventAddress event_offset = 1;

  // The event at this offset provided the event matches the filter.
  Event event = 2;
}
