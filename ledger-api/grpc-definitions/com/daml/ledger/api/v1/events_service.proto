// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0


/*
Satisfied Design goals:
- can co-exist with existing API services for single-domain participants
- can be served with the 1.17 IndexDB
- supports serving a snapshot and delta on the same stream
- serves transaction nodes in individual messages
- supports retrieving the transaction of a transaction node
- supports consumers in building the transaction tree

WIP:
- supports TransactionFilter
- provides clear docs for how the events are filtered
- minimize differences to existing transaction_service and active_contracts_service
- ensure that there is an efficient strategy for serving the stream

Next design goals:
- support evolving the interface to v2 multi-domain transactions
- include completions
- communicate pruning events
- include all data required for Ledger API completeness


*/



syntax = "proto3";

package com.daml.ledger.api.v1;

import "google/protobuf/wrappers.proto";
import "com/daml/ledger/api/v1/transaction_filter.proto";


option java_outer_classname = "EventsServiceServiceOuterClass";
option java_package = "com.daml.ledger.api.v1";
option csharp_namespace = "Com.Daml.Ledger.Api.V1";


service EventsService {
  // Get the address of a recent transaction as of which an event source can be provided.
  rpc GetRecentSnapshotOffset(GetRecentSnapshotOffsetRequest) returns (GetRecentSnapshotOffsetResponse);

  // Stream events while first serving all events required to reconstruct a state snapshot as
  // of a given transaction, and afterwards streaming changes to that state.
  rpc StreamEvents (StreamEventsRequest) returns (stream StreamEventsResponse);
}

// Transaction and event addresses
//////////////////////////////////

// A ledger-wide address of a transaction and the state it may depend on.
//
// `TransactionAddress` are partially ordered as per their vector clocks.
//
// TODO: VMBC
message TransactionAddress {
  // For each party there MUST be at most one `PartyVectorClock`
  repeated PartyVectorClock party_vector_clock = 1;
}

message PartyVectorClock {
  string party = 1;

  // For each domain there MUST be at most one `DomainClock`
  repeated DomainClock domain_vector_clock = 2;
}

message DomainClock {
  string domain = 1;
  int64 clock_time = 2;
}

// A ledger-wide address of an event and the state it may depend on.
// Comparisons are done in lexicographic order of the fields.
message EventAddress {
  TransactionAddress transaction_address = 1;
  
  // An index of the event within the transaction which is stable across participant nodes.
  //
  // Note: ledgers can decide to hide the node counts by assigning these indices using a
  // "monotone minimal perfect hash function", cf. https://www.cc.gatech.edu/~aboldyre/papers/operev.pdf
  int32 transaction_event_index = 2;
}


// Snapshots
////////////

message GetRecentSnapshotOffsetRequest {}

message GetRecentSnapshotOffsetResponse {
  // The address of the last transaction included in the snapshot.
  TransactionAddress snapshot_transaction_offset = 1;
}


// Event Streaming
//////////////////

message StreamEventsRequest {
  // The address of the last transaction included in the snapshot.
  // Retrieved from `GetRecentSnapshotOffset` or from client-side
  // storage in case of resuming a stream.
  //
  // Required.
  TransactionAddress snapshot_event_offset = 1;

  // Optional offset after which to serve the first event, which can
  // be set to resume streaming events.
  EventAddress after_event_offset = 2;

  // Projection determining what kind of events to serve with what data.
  EventProjection projection = 3; 

  // Filter determining which of the projected events to serve.
  // Required
  // 
  // TODO: expand filter or projection to select domains to consider.
  TransactionFilter filter = 4;

}

// The server guarantees to provide at least one `StreamEventsResponse` 
// every 100ms after ingesting new events from the subscribed domains.
message StreamEventsResponse {
  // The offset of this event, which is strictly monotonically increasing
  // for consecutive events wrt the order on `EventAddress`s.
  //
  // Thus all events from the same transaction will be served consecutively
  // and be assigned the same `TransactionAddress`.
  EventAddress event_offset = 1;

  // The event at this offset provided the event matches the filter.
  Event event = 2;
}

// Event Projection
///////////////////

/*

Design requirements:
- union streams
- filter streams specific to what one party can see
- filter streams to only show actions on contracts of a specific template
- show subtrees of exercise nodes
- selectively include: exercise nodes, divulgence nodes, fetch nodes, lookup by key nodes, create nodes, topology actions


exercise nodes: filter on informees == stakeholders + actors + choice observers
create nodes: filter on informees == stakeholders


event-seq-id : Int64 = [ index : 54bit | tags : 10bit ]

[ domain_id : 20bit | event_idx : 40bit | kind : 4bit ]

[ | reserved: 4bit | tx_idx: 50bit | reserved: 2bit | event_idx : 14bit | kind: 3bit | audit: 1bit ]


TABLE audit_events {
  tx_idx bigint
  event_payload bytes[] NOT NULL
}

TABLE state_events {
  event_idx bigint
  event_payload bytes NOT NULL
}

TABLE state_archivals {
  create_event_idx bigint
  archive_event_idx bigint
}

TABLE state_ids {
  bytes identifier NOT NULL,
  event_idx bigint NOT NULL
}

-- party and template filtering, package filtering? implements interface filtering?
TABLE events_attributes {
  attribute                  bigint NOT NULL,
  domain_event_idx           bigint NOT NULL, 
  subtree_end_event_idx_off  integer
}

TABLE event_archivals {
  archive_domain_id  integer NOT NULL,
  create_domain_id   integer NOT NULL,
  archive_event_idx  bigint  NOT NULL,
  create_event_idx   bigint  NOT NULL,
}

CREATE INDEX archival_idx1 ON event_archivals USING btree (create_domain_id, create_event_idx, archive)
CREATE INDEX archival_idx2 ON event_archivals USING btree (create_domain_id, create_event_idx)



TABLE contract_id_interning {
  contract_id
  event_sequential_id
}


*/



message TransactionProjection {
  bool include_exercise_subtrees = 1;
  EventProjection event_projection = 2;
}


// If no projection is set for a specific kind of event, then none of these events will be served.
//
// Use the default `EventProjection` to subscribe to just the changes of the ledger end.
//
// Note that the projections generally provide an opinionated set of of fields only.
message EventProjection {
  TransactionCommittedEventProjection transaction_committed_event_projection = 1;
  ContractCreatedEventProjection contract_created_event_projection = 2;
  ChoiceExercisedEventProjection exercised_event_projection = 4;
}

// No fine-grained projection available for now.
message TransactionCommittedEventProjection {}

// No fine-grained projection available for now. 
message ContractCreatedEventFieldSelector {
  // TODO: think about the difference of filtering on stakeholders for "flat" Transactions
  //       vs filtering on informees for TransactionTrees

  bool include_contract_id = 2;

  bool include_template_id = 3;

  bool include_contract_key = 7;

  bool include_create_arguments = 4;

  bool include_signatories = 8;

  bool include_observers = 9;

  bool include_agreement_text = 6;

  bool include_ledger_effective_time = 10;
}

message EventFilter {
  // Conjunction of basic filters
  repeated BasicFilter basic_filters = 1;
}

message BasicFilter {
  // stakeholders include set
  // implements interface, functions X
  // implements interface,
}

message FilterCondition {
  oneof condition {
    HasStakeholdersCondition has_stakeholders_condition = 1;
    HasInformeesCondition
  }
}

// TODO: think about what kind of projections are required.
message ChoiceExercisedEventProjection {
  enum Kind { 
    KIND_FULL = 0 ;          // corresponds to serving TransactionTrees
    KIND_ARCHIVALS_ONLY = 1; // corresponds to serving "flat" Transactions
  }

  Kind kind = 1;

  bool include_exercise_subtrees = 2;
}


// Events: copied from v1.events.proto with light adjustments.
//////////////////////////////////////////////////////////////

message Event {
    oneof kind {
        TransactionCommittedEvent transaction_committed_event = 1;
        ContractCreatedEvent contract_created_event = 2;
        ChoiceExercisedEvent exercised_event = 4;
    }
}

// Served as the first event of a transaction.
// TODO:
//  - filtering conditions
//    - option 1: Visible to the submitters and informees of the transaction.
//    - option 2: prefixed provided the stream contains an unfiltered event referring to this transaction
//    - other options?
//
// Changes relative to v1.Transaction and v1.TransactionTree:
//    - no need for `event_by_id` and `events`, as transaction boundary is communicated by TransactionAddress
//    - no need for `root_event_ids`, as nesting structure is specified using `descendant_event_offset_upper_bound`
//    - no need for `offset` as that is part of the `StreamEventsResponse`
message TransactionCommittedEvent {

  // A globally unique identifier useful to correlate transactions across different participant nodes.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Required
  string transaction_id = 1;

  // The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Optional
  string command_id = 2;

  // The workflow ID used in command submission. Only set if the ``workflow_id`` for the command was set.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Optional
  string workflow_id = 3;

  // Ledger effective time.
  // Required
  google.protobuf.Timestamp effective_at = 4;

  // TODO: potentially missing
  // string application_id = 6;
  // repeated string submitters = 7; 
}


// Records that a contract has been created, and choices may now be exercised on it.
//
// Changes relative to v1.CreatedEventd
//  - no `event_id`, as `EventAddress` structure communicates transaction scope and nesting
//  - include `ledger_effective_time`, as that is contract metadata relevant for state evolution
message ContractCreatedEvent {
  reserved 1; // was 'event_id'

  // The ID of the created contract.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Required
  string contract_id = 2;

  // The template of the created contract.
  // Required
  Identifier template_id = 3;

  // The key of the created contract, if defined.
  // Optional
  Value contract_key = 7;

  // The arguments that have been used to create the contract.
  // Required
  Record create_arguments = 4;

  // The parties that are notified of this event. When a ``CreatedEvent``
  // is returned as part of a transaction tree, this will include all
  // the parties specified in the ``TransactionFilter`` that are informees
  // of the event. If served as part of a flat transaction those will
  // be limited to all parties specified in the ``TransactionFilter`` that
  // are stakeholders of the contract (i.e. either signatories or observers).
  // Required
  repeated string witness_parties = 5;

  // The signatories for this contract as specified by the template.
  // Required
  repeated string signatories = 8;

  // The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
  // This field never contains parties that are signatories.
  // Required
  repeated string observers = 9;

  // The agreement text of the contract.
  // We use StringValue to properly reflect optionality on the wire for backwards compatibility.
  // This is necessary since the empty string is an acceptable (and in fact the default) agreement
  // text, but also the default string in protobuf.
  // This means a newer client works with an older sandbox seamlessly.
  // Optional
  google.protobuf.StringValue agreement_text = 6;

  // The time as of which this contract is present on the ledger.
  google.protobuf.Timestamp ledger_effective_time = 10;
}


// Records that a choice has been exercised on a target contract.
// 
// Changes compared to v1.ExercisedEvent
//  - replaced child_event_ids with descendant_event_offset_upper_bound, which is stable under filtering
//  - no `event_id`, as `EventAddress` structure communicates transaction scope and nesting
//  - include `ledger_effective_time`, as that is contract metadata relevant for state evolution
message ChoiceExercisedEvent {
  reserved 1; // was 'event_id'

  // The ID of the target contract.
  // Must be a valid LedgerString (as described in ``value.proto``).
  // Required
  string contract_id = 2;

  // The template of the target contract.
  // Required
  Identifier template_id = 3;

  // The choice that's been exercised on the target contract.
  // Must be a valid NameString (as described in ``value.proto``).
  // Optional for ARCHIVALS_ONLY
  string choice = 5;

  // The argument the choice was made with.
  // Optional for ARCHIVALS_ONLY
  Value choice_argument = 6;

  // The parties that made the choice.
  // Each element must be a valid PartyIdString (as described in ``value.proto``).
  // Optional for ARCHIVALS_ONLY
  repeated string acting_parties = 7;

  // If true, the target contract may no longer be exercised.
  // Required
  bool consuming = 8;

  reserved 9; // removed field

  // The parties that are notified of this event. The witnesses of an exercise
  // node will depend on whether the exercise was consuming or not.
  // If consuming, the witnesses are the union of the stakeholders and
  // the actors.
  // If not consuming, the witnesses are the union of the signatories and
  // the actors. Note that the actors might not necessarily be observers
  // and thus signatories. This is the case when the controllers of a
  // choice are specified using "flexible controllers", using the
  // ``choice ... controller`` syntax, and said controllers are not
  // explicitly marked as observers.
  // Each element must be a valid PartyIdString (as described in ``value.proto``).
  // Optional for ARCHIVALS_ONLY
  repeated string witness_parties = 10;

  reserved 11; // was repeated string child_event_ids = 11;

  // An upper bound that is larger or equal to the largest `LocalEventAddress` of any descendant event.
  // Optional for ARCHIVALS_ONLY
  LocalEventAddress descendant_event_offset_upper_bound = 14;

  // The result of exercising the choice
  // Optional for ARCHIVALS_ONLY
  Value exercise_result = 12;

  // The time as of which this choice is effective on the ledger.
  // Required.
  google.protobuf.Timestamp ledger_effective_time = 13;
}

  

// Scratchpad: Completions
/*

  message SubmissionAcceptedEvent {
  
  }
  message SubmissionInfo {
    string application_id = 1;
    repeated string submitters = 2;
    string command_id = 3;
  }
  message SubmissionRejectedEvent {
    SubmissionInfo submission_info = 1;
    // status code
  }
*/

