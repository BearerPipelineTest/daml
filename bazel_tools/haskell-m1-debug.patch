diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index 6f606be3..7bbe6dbf 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -172,10 +172,11 @@ def _cabal_toolchain_info(hs, cc, workspace_name, runghc):
         runghc = runghc.path,
         ar = ar,
         cc = cc.tools.cc,
+        ld = cc.tools.ld,
         strip = cc.tools.strip,
         is_windows = hs.toolchain.is_windows,
         workspace = workspace_name,
-        ghc_cc_args = ghc_cc_program_args(hs, "$CC"),
+        ghc_cc_args = ghc_cc_program_args(hs, "$CC", cc.tools.ld),
     )
 
 def _prepare_cabal_inputs(
diff --git a/haskell/cc.bzl b/haskell/cc.bzl
index 3726133c..1eeee540 100644
--- a/haskell/cc.bzl
+++ b/haskell/cc.bzl
@@ -186,11 +186,12 @@ def cc_interop_info(ctx, override_cc_toolchain = None):
         ]).linking_context.linker_inputs.to_list() for lib in li.libraries],
     )
 
-def ghc_cc_program_args(hs, cc):
+def ghc_cc_program_args(hs, cc, ld):
     """Returns the -pgm* flags required to override cc.
 
     Args:
       cc: string, path to the C compiler (cc_wrapper).
+      ld: string, path to the linker (ld).
 
     Returns:
       list of string, GHC arguments.
@@ -203,6 +204,8 @@ def ghc_cc_program_args(hs, cc):
         cc,
         "-pgml",
         cc,
+        "-pgmlm",
+        ld,
         # Setting -pgm* flags explicitly has the unfortunate side effect
         # of resetting any program flags in the GHC settings file. So we
         # restore them here. See
@@ -217,6 +220,8 @@ def ghc_cc_program_args(hs, cc):
         "-pgmP",
         cc + " -E -undef -traditional",
         "-optc-fno-stack-protector",
+        "-optlm",
+        "-r",
     ]
     if hs.toolchain.numeric_version >= [8, 10, 3]:
         args.append("-pgmc-supports-no-pie")
diff --git a/haskell/doctest.bzl b/haskell/doctest.bzl
index 1cd3f675..f7a2200a 100644
--- a/haskell/doctest.bzl
+++ b/haskell/doctest.bzl
@@ -98,7 +98,7 @@ def _haskell_doctest_single(target, ctx):
         ctx,
         override_cc_toolchain = hs.tools_config.maybe_exec_cc_toolchain,
     )
-    args.add_all(ghc_cc_program_args(hs, cc.tools.cc))
+    args.add_all(ghc_cc_program_args(hs, cc.tools.cc, cc.tools.ld))
 
     doctest_log = ctx.actions.declare_file(
         "doctest-log-" + ctx.label.name + "-" + target.label.name,
diff --git a/haskell/private/actions/compile.bzl b/haskell/private/actions/compile.bzl
index c2225c10..1923f652 100644
--- a/haskell/private/actions/compile.bzl
+++ b/haskell/private/actions/compile.bzl
@@ -101,6 +101,7 @@ def _process_hsc_file(hs, cc, hsc_flags, hsc_inputs, hsc_file):
         """.format(mingw_bin = paths.dirname(cc.tools.cc)) if hs.toolchain.is_windows else ""
             ) +
             """
+        set -x
         # Include libdir in include path just like hsc2hs does.
         libdir=$({ghc} --print-libdir)
         # GHC >=9 on Windows stores the includes outside of libdir
diff --git a/haskell/private/cabal_wrapper.py b/haskell/private/cabal_wrapper.py
index 6dd634e1..5dbf2654 100755
--- a/haskell/private/cabal_wrapper.py
+++ b/haskell/private/cabal_wrapper.py
@@ -49,8 +49,8 @@ import sys
 import tempfile
 from generate_cabal_paths_module import generate_cabal_paths_module
 
-debug = False
-verbose = os.environ.get("CABAL_VERBOSE", "") == "True"
+debug = True
+verbose = True
 with open(sys.argv.pop(1)) as json_file:
     json_args = json.load(json_file)
 
@@ -128,6 +128,7 @@ path_args = json_args["path_args"]
 
 ar = find_exe(toolchain_info["ar"])
 cc = find_exe(toolchain_info["cc"])
+ld = find_exe(toolchain_info["ld"])
 strip = find_exe(toolchain_info["strip"])
 
 def recache_db():
@@ -156,7 +157,8 @@ def mkdtemp(prefix):
     try:
         yield dirname
     finally:
-        shutil.rmtree(dirname, ignore_errors = True)
+        pass
+        #shutil.rmtree(dirname, ignore_errors = True)
 
 def distdir_prefix():
     # Build into a sibling path of the final binary output location.
@@ -249,17 +251,26 @@ with mkdtemp(distdir_prefix()) as distdir:
     runghc_args = [arg.replace("./", execroot + "/") for arg in runghc_args]
     run([runghc] + runghc_args + [setup, "configure", \
         component, \
-        "--verbose=0", \
+        "--verbose=3", \
         "--user", \
         "--with-compiler=" + ghc,
         "--with-hc-pkg=" + ghc_pkg,
         "--with-hsc2hs=" + hsc2hs,
         "--with-ar=" + ar,
         "--with-gcc=" + cc,
+        "--with-ld=" + ld,
         "--with-strip=" + strip,
         "--enable-deterministic", \
+        "--ghc-option=-keep-tmp-files",
+        "--ghc-option=-v",
+        "--disable-response-files",
         ] +
         [ "--ghc-option=" + flag.replace("$CC", cc) for flag in toolchain_info["ghc_cc_args"] ] +
+        [ "--hsc2hs-option=-c" + cc,
+          "--hsc2hs-option=-l" + cc,
+          "--hsc2hs-option=-v",
+          "--hsc2hs-option=-k",
+        ] +
         enable_relocatable_flags + \
         [ \
         # Make `--builddir` a relative path. Using an absolute path would
@@ -286,17 +297,17 @@ with mkdtemp(distdir_prefix()) as distdir:
         [ arg.replace("=", "=" + execroot + "/") for arg in path_args ] + \
         [ "--package-db=" + package_database ], # This arg must come last.
         )
-    run([runghc] + runghc_args + [setup, "build", "--verbose=0", "--builddir=" + distdir])
+    run([runghc] + runghc_args + [setup, "build", "--verbose=3", "--builddir=" + distdir])
     if haddock:
-        run([runghc] + runghc_args + [setup, "haddock", "--verbose=0", "--builddir=" + distdir])
-    run([runghc] + runghc_args + [setup, "install", "--verbose=0", "--builddir=" + distdir])
+        run([runghc] + runghc_args + [setup, "haddock", "--verbose=3", "--builddir=" + distdir])
+    run([runghc] + runghc_args + [setup, "install", "--verbose=3", "--builddir=" + distdir])
     # Bazel builds are not sandboxed on Windows and can be non-sandboxed on
     # other OSs. Operations like executing `configure` scripts can modify the
     # source tree. If the `srcs` attribute uses a glob like `glob(["**"])`,
     # then these modified files will enter `srcs` on the next execution and
     # invalidate the cache. To avoid this we remove generated files.
-    run([runghc] + runghc_args + [setup, "clean", "--verbose=0", "--builddir=" + distdir])
-    if generated_paths_file: os.remove(generated_paths_file)
+    #run([runghc] + runghc_args + [setup, "clean", "--verbose=3", "--builddir=" + distdir])
+    #if generated_paths_file: os.remove(generated_paths_file)
     os.chdir(old_cwd)
 
 # XXX Cabal has a bizarre layout that we can't control directly. It
diff --git a/haskell/private/cc_wrapper.py.tpl b/haskell/private/cc_wrapper.py.tpl
index 311c0f96..79c3c4fa 100644
--- a/haskell/private/cc_wrapper.py.tpl
+++ b/haskell/private/cc_wrapper.py.tpl
@@ -84,17 +84,30 @@ CC = os.environ.get("CC_WRAPPER_CC_PATH", "{:cc:}")
 PLATFORM = os.environ.get("CC_WRAPPER_PLATFORM", "{:platform:}")
 CPU = os.environ.get("CC_WRAPPER_CPU", "{:cpu:}")
 INSTALL_NAME_TOOL = "/usr/bin/install_name_tool"
+CODESIGN = "/usr/bin/codesign"
 OTOOL = "/usr/bin/otool"
 
+hdebug = open("/tmp/cc_wrapper.log", "a")
+def debug(*args, **kwargs):
+    print(*args, file=hdebug, **kwargs)
+
 
 def main():
+    debug(60*"=")
     parsed = Args(load_response_files(sys.argv[1:]))
 
+    debug("ENV\n" + "\n".join(f"  {k}: {v}" for k, v in os.environ.items()))
     if parsed.linking:
+        debug("LINK", parsed.output)
+        debug("  LIBRARIES\n" + "\n".join(f"    {v}" for v in parsed.libraries))
+        debug("  RPATHS\n" + "\n".join(f"    {v}" for v in parsed.rpaths))
+        debug("  ARGS\n" + "\n".join(f"    {v}" for v in parsed.args))
         link(parsed.output, parsed.libraries, parsed.rpaths, parsed.args)
     elif parsed.printing_file_name:
+        debug("PRINT_FILE_NAME " + parsed.print_file_name + "\n" + "\n".join(f"  {v}" for v in parsed.args))
         print_file_name(parsed.print_file_name, parsed.args)
     else:
+        debug("CC\n" + "\n".join(f"  {v}" for v in parsed.args))
         run_cc(parsed.args, exit_on_error=True)
 
 
@@ -937,7 +950,11 @@ def darwin_rewrite_load_commands(rewrites, output):
     for old, new in rewrites:
         args.extend(["-change", old, os.path.join("@rpath", new)])
     if args:
+        debug("INSTALL_NAME_TOOL\n" + "\n".join(f"    {v}" for v in [INSTALL_NAME_TOOL] + args + [output]))
         subprocess.check_call([INSTALL_NAME_TOOL] + args + [output])
+        os.rename(output, f"{output}.resign")
+        subprocess.check_call([CODESIGN] + ["-f", "-s", "-"] + [f"{output}.resign"])
+        os.rename(f"{output}.resign", output)
 
 
 # --------------------------------------------------------------------
@@ -1042,7 +1059,8 @@ def run_cc(args, capture_output=False, exit_on_error=False, **kwargs):
         stderrbuf: The captured standard error, None if not capture_output.
 
     """
-    if capture_output:
+    #if capture_output:
+    if True:
         # The capture_output argument to subprocess.run was only added in 3.7.
         new_kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         new_kwargs.update(kwargs)
@@ -1051,18 +1069,34 @@ def run_cc(args, capture_output=False, exit_on_error=False, **kwargs):
     cc = find_cc()
 
     def _run_cc(args):
+        environ = os.environ.copy()
+        environ["NIX_DEBUG"] = "1"
         # subprocess.run is not supported in the bindist CI setup.
         # subprocess.Popen does not support context manager on CI setup.
-        proc = subprocess.Popen([cc] + args, **kwargs)
+        proc = subprocess.Popen([cc] + args, env=environ, **kwargs)
 
-        if capture_output:
+        #if capture_output:
+        if True:
             (stdoutbuf, stderrbuf) = proc.communicate()
-        else:
-            stdoutbuf = None
-            stderrbuf = None
+        #else:
+        #    stdoutbuf = None
+        #    stderrbuf = None
 
         returncode = proc.wait()
 
+        debug("RUN\n  " + cc + " " + " ".join(args))
+        debug("RETURNCODE", returncode)
+        debug("STDOUT")
+        debug(stdoutbuf.decode(errors = "replace"))
+        debug("STDERR")
+        debug(stderrbuf.decode(errors = "replace"))
+
+        if not capture_output:
+            sys.stdout.buffer.write(stdoutbuf)
+            sys.stderr.buffer.write(stderrbuf)
+            stdoutbuf = None
+            stderrbuf = None
+
         if exit_on_error and returncode != 0:
             if capture_output:
                 sys.stdout.buffer.write(stdoutbuf)
diff --git a/haskell/repl.bzl b/haskell/repl.bzl
index 6cc44499..ab001cd6 100644
--- a/haskell/repl.bzl
+++ b/haskell/repl.bzl
@@ -396,7 +396,7 @@ def _create_repl(hs, cc, posix, ctx, repl_info, output):
         "$RULES_HASKELL_EXEC_ROOT",
         hs.toolchain.cc_wrapper.executable.path,
     )
-    args.extend(['"{}"'.format(arg) for arg in ghc_cc_program_args(hs, cc_path)])
+    args.extend(['"{}"'.format(arg) for arg in ghc_cc_program_args(hs, cc_path, cc.tools.ld)])
 
     # Load source files
     # Force loading by source with `:add *...`.
@@ -518,7 +518,7 @@ def _create_hie_bios(hs, cc, posix, ctx, repl_info, path_prefix):
     path_prefix = paths.join("", *path_prefix)
     args, inputs = _compiler_flags_and_inputs(hs, cc, repl_info, path_prefix = path_prefix, static = True)
     cc_path = paths.join(path_prefix, hs.toolchain.cc_wrapper.executable.path)
-    args.extend(ghc_cc_program_args(hs, cc_path))
+    args.extend(ghc_cc_program_args(hs, cc_path, cc.tools.ld))
     args.extend(hs.toolchain.ghcopts)
     args.extend(repl_info.load_info.compiler_flags)
 
diff --git a/haskell/toolchain.bzl b/haskell/toolchain.bzl
index 2cecc0b8..74f72163 100644
--- a/haskell/toolchain.bzl
+++ b/haskell/toolchain.bzl
@@ -46,7 +46,7 @@ def _run_ghc(hs, cc, inputs, outputs, mnemonic, arguments, env, params_file = No
 
     # XXX: We should also tether Bazel's CC toolchain to GHC's, so that we can properly mix Bazel-compiled
     # C libraries with Haskell targets.
-    args.add_all(ghc_cc_program_args(hs, cc.tools.cc))
+    args.add_all(ghc_cc_program_args(hs, cc.tools.cc, cc.tools.ld))
 
     compile_flags_file = hs.actions.declare_file("compile_flags_%s_%s_%s" % (hs.name, extra_name, mnemonic))
     extra_args_file = hs.actions.declare_file("extra_args_%s_%s_%s" % (hs.name, extra_name, mnemonic))
