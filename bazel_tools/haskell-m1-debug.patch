diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index 6f606be3..77f8c8bd 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -172,6 +172,7 @@ def _cabal_toolchain_info(hs, cc, workspace_name, runghc):
         runghc = runghc.path,
         ar = ar,
         cc = cc.tools.cc,
+        ld = cc.tools.ld,
         strip = cc.tools.strip,
         is_windows = hs.toolchain.is_windows,
         workspace = workspace_name,
diff --git a/haskell/private/cabal_wrapper.py b/haskell/private/cabal_wrapper.py
index 6dd634e1..bc30850e 100755
--- a/haskell/private/cabal_wrapper.py
+++ b/haskell/private/cabal_wrapper.py
@@ -49,8 +49,8 @@ import sys
 import tempfile
 from generate_cabal_paths_module import generate_cabal_paths_module
 
-debug = False
-verbose = os.environ.get("CABAL_VERBOSE", "") == "True"
+debug = True
+verbose = True
 with open(sys.argv.pop(1)) as json_file:
     json_args = json.load(json_file)
 
@@ -128,6 +128,7 @@ path_args = json_args["path_args"]
 
 ar = find_exe(toolchain_info["ar"])
 cc = find_exe(toolchain_info["cc"])
+ld = find_exe(toolchain_info["ld"])
 strip = find_exe(toolchain_info["strip"])
 
 def recache_db():
@@ -249,13 +250,14 @@ with mkdtemp(distdir_prefix()) as distdir:
     runghc_args = [arg.replace("./", execroot + "/") for arg in runghc_args]
     run([runghc] + runghc_args + [setup, "configure", \
         component, \
-        "--verbose=0", \
+        "--verbose=3", \
         "--user", \
         "--with-compiler=" + ghc,
         "--with-hc-pkg=" + ghc_pkg,
         "--with-hsc2hs=" + hsc2hs,
         "--with-ar=" + ar,
         "--with-gcc=" + cc,
+        "--with-ld=" + ld,
         "--with-strip=" + strip,
         "--enable-deterministic", \
         ] +
@@ -286,16 +288,16 @@ with mkdtemp(distdir_prefix()) as distdir:
         [ arg.replace("=", "=" + execroot + "/") for arg in path_args ] + \
         [ "--package-db=" + package_database ], # This arg must come last.
         )
-    run([runghc] + runghc_args + [setup, "build", "--verbose=0", "--builddir=" + distdir])
+    run([runghc] + runghc_args + [setup, "build", "--verbose=3", "--builddir=" + distdir])
     if haddock:
-        run([runghc] + runghc_args + [setup, "haddock", "--verbose=0", "--builddir=" + distdir])
-    run([runghc] + runghc_args + [setup, "install", "--verbose=0", "--builddir=" + distdir])
+        run([runghc] + runghc_args + [setup, "haddock", "--verbose=3", "--builddir=" + distdir])
+    run([runghc] + runghc_args + [setup, "install", "--verbose=3", "--builddir=" + distdir])
     # Bazel builds are not sandboxed on Windows and can be non-sandboxed on
     # other OSs. Operations like executing `configure` scripts can modify the
     # source tree. If the `srcs` attribute uses a glob like `glob(["**"])`,
     # then these modified files will enter `srcs` on the next execution and
     # invalidate the cache. To avoid this we remove generated files.
-    run([runghc] + runghc_args + [setup, "clean", "--verbose=0", "--builddir=" + distdir])
+    run([runghc] + runghc_args + [setup, "clean", "--verbose=3", "--builddir=" + distdir])
     if generated_paths_file: os.remove(generated_paths_file)
     os.chdir(old_cwd)
 
diff --git a/haskell/private/cc_wrapper.py.tpl b/haskell/private/cc_wrapper.py.tpl
index 311c0f96..443687e4 100644
--- a/haskell/private/cc_wrapper.py.tpl
+++ b/haskell/private/cc_wrapper.py.tpl
@@ -86,15 +86,27 @@ CPU = os.environ.get("CC_WRAPPER_CPU", "{:cpu:}")
 INSTALL_NAME_TOOL = "/usr/bin/install_name_tool"
 OTOOL = "/usr/bin/otool"
 
+hdebug = open("/tmp/cc_wrapper.log", "a")
+def debug(*args, **kwargs):
+    print(*args, file=hdebug, **kwargs)
+
 
 def main():
+    debug(60*"=")
     parsed = Args(load_response_files(sys.argv[1:]))
 
+    debug("ENV\n" + "\n".join(f"  {k}: {v}" for k, v in os.environ.items()))
     if parsed.linking:
+        debug("LINK", parsed.output)
+        debug("  LIBRARIES\n" + "\n".join(f"    {v}" for v in parsed.libraries))
+        debug("  RPATHS\n" + "\n".join(f"    {v}" for v in parsed.rpaths))
+        debug("  ARGS\n" + "\n".join(f"    {v}" for v in parsed.args))
         link(parsed.output, parsed.libraries, parsed.rpaths, parsed.args)
     elif parsed.printing_file_name:
+        debug("PRINT_FILE_NAME " + parsed.print_file_name + "\n" + "\n".join(f"  {v}" for v in parsed.args))
         print_file_name(parsed.print_file_name, parsed.args)
     else:
+        debug("CC\n" + "\n".join(f"  {v}" for v in parsed.args))
         run_cc(parsed.args, exit_on_error=True)
 
 
@@ -1042,7 +1054,8 @@ def run_cc(args, capture_output=False, exit_on_error=False, **kwargs):
         stderrbuf: The captured standard error, None if not capture_output.
 
     """
-    if capture_output:
+    #if capture_output:
+    if True:
         # The capture_output argument to subprocess.run was only added in 3.7.
         new_kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         new_kwargs.update(kwargs)
@@ -1055,14 +1068,27 @@ def run_cc(args, capture_output=False, exit_on_error=False, **kwargs):
         # subprocess.Popen does not support context manager on CI setup.
         proc = subprocess.Popen([cc] + args, **kwargs)
 
-        if capture_output:
+        #if capture_output:
+        if True:
             (stdoutbuf, stderrbuf) = proc.communicate()
-        else:
-            stdoutbuf = None
-            stderrbuf = None
+        #else:
+        #    stdoutbuf = None
+        #    stderrbuf = None
 
         returncode = proc.wait()
 
+        debug("RUN\n  " + cc + " " + " ".join(args))
+        debug("STDOUT")
+        debug(stdoutbuf.decode(errors = "replace"))
+        debug("STDERR")
+        debug(stderrbuf.decode(errors = "replace"))
+
+        if not capture_output:
+            sys.stdout.buffer.write(stdoutbuf)
+            sys.stderr.buffer.write(stderrbuf)
+            stdoutbuf = None
+            stderrbuf = None
+
         if exit_on_error and returncode != 0:
             if capture_output:
                 sys.stdout.buffer.write(stdoutbuf)
